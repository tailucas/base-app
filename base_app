#!/usr/bin/env python
import logging.handlers

import builtins
import os
import threading
import zmq

from pathlib import Path
from zmq.error import ContextTerminated

# setup builtins used by pylib init
app_name = Path(__file__).stem
builtins.APP_NAME = app_name
builtins.SENTRY_EXTRAS = []


class CredsConfig:
    sentry_dsn: f'opitem:"Sentry" opfield:{app_name}.dsn' = None  # type: ignore
    cronitor_token: f'opitem:"cronitor" opfield:.password' = None  # type: ignore


builtins.creds_config = CredsConfig()


from lib import app_config, \
    creds, \
    device_name, \
    device_name_base, \
    log, \
    log_handler

from lib.datetime import is_list, \
    make_timestamp, \
    make_unix_timestamp, \
    parse_datetime, \
    ISO_DATE_FORMAT
from lib.process import SignalHandler
from lib.rabbit import MQConnection, ZMQListener
from lib import threads
from lib.threads import thread_nanny, die
from lib.app import AppThread, ZmqRelay
from lib.zmq import zmq_term, Closable
from lib.handler import exception_handler


URL_WORKER_APP = 'inproc://app-worker'


class DataReader(AppThread, Closable):

    def __init__(self):
        AppThread.__init__(self, name=self.__class__.__name__)
        Closable.__init__(self)

        self.processor = self.get_socket(zmq.PUSH)  # type: ignore

        self._prefix = 'time'

    def get_data(self):
        timestamp = make_timestamp(make_string=True)
        return f'{self._prefix}: {timestamp}'

    def run(self):
        self.processor.connect(URL_WORKER_APP)
        with exception_handler(closable=self):
            while not threads.shutting_down:
                data = self.get_data()
                log.debug(f'Data is {data}')
                threads.interruptable_sleep.wait(60)


class EventProcessor(AppThread, Closable):

    def __init__(self):
        AppThread.__init__(self, name=self.__class__.__name__)
        Closable.__init__(self, connect_url=URL_WORKER_APP)

    # noinspection PyBroadException
    def run(self):
        with exception_handler(closable=self, and_raise=False, shutdown_on_error=True):
            while not threads.shutting_down:
                event = self.socket.recv_pyobj()
                log.debug(event)


if __name__ == "__main__":
    log.setLevel(logging.INFO)
    # ensure proper signal handling; must be main thread
    signal_handler = SignalHandler()
    event_processor = EventProcessor()
    data_reader = DataReader()
    nanny = threading.Thread(
        name='nanny',
        target=thread_nanny,
        args=(signal_handler,),
        daemon=True)
    # startup completed
    # back to INFO logging
    log.setLevel(logging.INFO)
    try:
        log.info('Starting application threads...')
        event_processor.start()
        data_reader.start()
        # start thread nanny
        nanny.start()
        env_vars = list(os.environ)
        env_vars.sort()
        log.info(f'Startup complete with {len(env_vars)} environment variables visible: {env_vars}.')
        # hang around until something goes wrong
        threads.interruptable_sleep.wait()
        raise RuntimeWarning("Shutting down...")
    except(KeyboardInterrupt, RuntimeWarning, ContextTerminated) as e:
        log.warning(str(e))
        threads.shutting_down = True
        threads.interruptable_sleep.set()
    finally:
        zmq_term()
    log.info('Shutdown complete.')
